package hu.webarticum.miniconnect.jdbc;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;

import hu.webarticum.miniconnect.api.MiniError;
import hu.webarticum.miniconnect.api.MiniResult;

public class MiniJdbcStatement extends AbstractJdbcStatement {

    private final Object closeLock = new Object();
    
    private volatile boolean closed = false;
    
    
    public MiniJdbcStatement(MiniJdbcConnection connection) {
        super(connection);
    }


    @Override
    public void setPoolable(boolean poolable) throws SQLException {
        // not supported
    }

    @Override
    public boolean isPoolable() throws SQLException {
        return false;
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        ResultHolder resultHolder = executeInternal(sql);
        return resultHolder.jdbcResultSet;
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        executeInternal(sql);
        return 0; // TODO
    }
    
    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        return executeUpdate(sql);
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        return executeUpdate(sql);
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        return executeUpdate(sql);
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        ResultHolder resultHolder = executeInternal(sql);
        return resultHolder.result.hasResultSet();
    }
    
    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        return execute(sql);
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        return execute(sql);
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        return execute(sql);
    }

    private ResultHolder executeInternal(String sql) throws SQLException {
        MiniResult result = getConnection().getMiniSession().execute(sql);
        if (!result.success()) {
            MiniError error = result.error();
            throw new SQLException(
                    error.message(),
                    error.sqlState(),
                    error.code());
        }
        
        MiniJdbcResultSet jdbcResultSet =
                result.hasResultSet() ?
                new MiniJdbcResultSet(this, result.resultSet()) :
                null;
        ResultHolder resultHolder = new ResultHolder(result, jdbcResultSet);
        handleExecuteCompleted(resultHolder);
        
        return resultHolder;
    }

    @Override
    public void addBatch(String sql) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    @Override
    public int[] executeBatch() throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    @Override
    public void clearBatch() throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    @Override
    public boolean isClosed() throws SQLException {
        return closed;
    }
    
    @Override
    public void close() throws SQLException {
        synchronized (closeLock) {
            if (!closed) {
                closeInternal();
            }
        }
    }

    public void closeInternal() throws SQLException {
        closed = true;
        getConnection().unregisterActiveStatement(this);
        try {
            ResultSet resultSet = getResultSet();
            if (resultSet != null) {
                resultSet.close();
            }
        } catch (SQLException e) {
            throw e;
        } catch (Exception e) {
            throw new SQLException(e);
        }
    }
    
}
